### sizeof和strlen

sizeof是运算符，strlen是库函数

sizeof参数不限，strlen参数只能是字符串

sizeof在编译器确定，不能得到动态分配空间的大小

### struct和class

成员和继承：struct默认是公有的，class则默认是私有的

### define和typedef

define定义常量，预处理阶段，没有类型检查，不是语句不加分号

typedef定义别名，编译阶段，有类型检查，是语句加分号

### define和const

define是预处理阶段，没有类型检查，没有分配内存

const是编译运行阶段，有类型检查，有分配内存

### static和const

不考虑类的情况（加static）

- 静态全局变量和静态局部变量默认初始化为0，存在静态存储区

- 静态变量和静态函数只能在本文件中使用
- 静态局部变量范围只在本函数，函数退出后仍然存在但不能使用

考虑类的情况（加static）

- 静态函数在代码段

- 静态成员变量类外初始化

- 静态变量和静态函数只与类关联，不与类的对象关联
- 静态成员函数不具有this指针，所以不能引用非静态成员和函数（因为非静态成员还没初始化）。
- 不管该静态变量的作用域为private还是public，因为编译期间private没有影响，静态变量在编译期间必须初始化，编译的时候就分配内存了,直到程序退出才释放,并不是随着对象的删除而释放的。

不考虑类的情况（加const）

- const常量定义时必须初始化，且无法修改。
- const形参可以接受const和非const类型

考虑类的情况（加const）

- const成员变量：必须在构造函数初始化列表初始化
- const成员函数：不可以调用非const成员函数，不可以改变非mutable数据的值

补充：const放函数前的作用：返回值是右值，返回的是指针则必须用const类型指针去接

**顶层**const：int * const p;p指针不可以修改。底层const：int const *p;p指针指向的值不可以修改

### override和final

override指定了子类的这个虚函数是重写的父类的

final指定了类不允许继承或虚函数不允许重写

补充：在重写基类虚函数的时候，派生类的虚函数不加关键字virtual也可以构成重写，但是这种写法不规范

### volatile、mutable和explicit

volatile是防止编译器优化

mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中或者常量对象中

explicit修饰类的单个参数的构造函数，这个类只能显示类型转换

### new和malloc

关键字，库函数

new封装了malloc

new会调用构造函数

new自动计算内存大小malloc需要指定内存的大小

new返回对象类型指针，malloc返回值是void*

分配失败new抛出异常，malloc返回NULL

### malloc与free的实现原理

小于128k是brk，大于128k是mmap

### 堆和栈

### 数组和指针

- 数组和指针都可通过增减偏移量访问元素
- 数组是常指针没有自增自减但有sizeof得到数组大小
- 指针有自增自减，sizeof是指针大小
- 数组作为形参传递退化成指针

### 指针和引用

### 左值和右值

### 浅拷贝和深拷贝

### 构造函数执行顺序

- 虚基类构造函数
- 基类构造函数
- 成员对象构造函数
- 自己的构造函数